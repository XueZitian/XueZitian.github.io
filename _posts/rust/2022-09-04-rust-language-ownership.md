---
layout: post
title: Rust所有权
category: rust
---

所有权是Rust语言最独特的特性，对语言的其余部分有很深的影响。它使是Rust能够在不使用垃圾收集器的情况下保证了内存安全。

## 1 所有权

所有权(Ownership)是一组规则，用于控制Rust程序如何管理内存。所有的编程语言都必须管理他们在运行时使用计算机内存的方式，有些语言提供了垃圾收集器(GC, garbage collection)，GC会在运行时定期查找不再使用的内存，比如Java；还有一些语言，程序员必须在代码中显性的管理内存的申请和释放，比如c语言。Rust语言使用了第三种方法：内存通过所有权系统进行管理，该系统具有一组编译器检查的规则，即编程规则 + 编译器检查来约束。一旦有违反规则的地方，在编译器阶段即被拦截下来，运行时就不需要有像GC那样的额外开销。而c语言虽然效率高，但是c语言将内存管理完全丢给了程序员，一旦代码中内存管理出现漏洞，问题直接蔓延到了运行时，这种内存管理方式对程序员的要求极高，缺少规则的确定性约束，导致无法保证内存的绝对安全。

   | 内存管理方式 | 优势                   | 缺点          |
   |------------|-----------------------|---------------|
   |   GC       |  内存安全，编程模型简单   | 影响程序运行的效率，GC的运行时开销   |
   |   显性管理 | 程序运行时效率高，极大的编程灵活性 | 内存安全无法保证，对程序员的编程经验和能力要求高 |
   |   所有权    |  内存安全，且兼顾运行时的高效率 | 由于所有权规则的约束，编程灵活性受到一定限制 |

### 1.1 堆和栈

对于系统编程语言，堆和栈是重要的概念，Rust的定位就是一门系统编程语言。一个数据放在堆还是栈中，是有差别的，这会影响语言的行为方式以及性能。堆和栈都是代码在运行时可以使用的内存部分，但他们的结构是不同的。

栈按照获取值的顺序存储值，并以相反的顺序删除值，这被称作last in， first out。添加数据被称作Pushing，删除数据被称作Popping。所有存储在栈中的数据都必须是已知的、固定大小。编译时大小未知或者大小可能发生变化的数据必须存储在堆中。

堆的内存使用方式比较灵活，栈一般是由编译器来管理的，堆需要一个内存分配器来管理内存的申请和释放。当你需要放数据在堆中时，内存分配器首先会寻找一块足够大的空闲区域，然后将这块区域标记为已用，并返回一个指针，该指针是这个区域的地址。这个过程被称为：allocating。

显然，栈的Pushing操作是要快于堆的allocationg，因为栈在存储一个数据时，并不需要先搜索一个可用的位置，栈是直接基于栈顶向下增长的。另外，现代处理器连续访问跨度更小的内存的速度也会更快，基于这一点，可以认为数据放在栈中比放在堆中也会更有一些效率上的优势。因为，一般情况下处理器频繁访问的数据都是放在栈里，比如当一个函数被调用时，入参和函数的局部变量都是存储在栈中，不过当函数退出时，这些数据也会随之会被pop出栈。所有对于一些作用域超出一个函数的数据就适合放在堆中。

跟踪代码的哪些部分正在使用堆上的哪些数据，最大限度地减少堆上重复数据的数量，以及清理堆上未使用的数据来避免空间不足，这些都是所有权解决的问题。一旦你理解了所有权，你就不需要经常考虑栈和堆，但是理解所有权的主要目的是管理堆数据可以帮助解释它为什么会这样工作。

### 1.2 所有权规则

所有权的规则如下：
* Rust中的每一个数值都有一个所有者
* 数据一次只能有一个所有者
* 当所有者超出作用域时，该值将被删除

### 1.3 变量作用域

与其它语言类似，Rust的变量也有作用域的概念，作用域是一个元素在一个程序中的有效区域，例如下面这个例子：
```rust
    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    } 
```

### 1.4 String类型

为了更好的解释Rust所有权，需要一个更加复杂的数据类型来辅助，String很适合拿来举例子。

之前提到的标量和复合类型，都是有已知的大小，可以存储在栈中，当超出作用域时，也会随之pop出栈，而如若代码的另一部分需要在另一个作用域中使用先前作用域中的数值时，只需要创建一个新的实例，然后快速且低代价的将先前的数值拷贝给新的实例即可。

那么，对于存储在堆中的数据，Rust是如何知道何时清理这些数据的呢？我们可以基于String类型来看看。

对于字符串，我们可以选择将字符串字面量硬编码到程序中，**此时s变量的类型是什么？**
```rust
let s = "hello";
```

上面的做法虽然简单，但不够灵活，比如如果我们希望可以修改字符串的内容，上面的方法就无法满足，因为它是不可变的，另外，可能在写代码时我们并不知道字符串的内容，比如存储键盘输入的字符串的场景。String类型可以满足上面的需求，String类型可以管理在堆中申请的内存，因此能够存储我们在编译时不知道的大量文本。可以使用from函数基于字符串字面量创建字符串变量，如下：**此时s变量的类型是什么？**
```rust
// immutable
let s = String::from("hello");
// mutable
let mut s = String::from("hello");
```

### 1.5 内存和分配

字符串字面常量是在编译时被硬编码在可执行程序中，所以字符串常量的使用是快速和高效的。String类型，为了支持可变的且可以增长的文本，需要在堆中分配一定量的内存，但这在编译时是未知的，这意味着：
* 内存必须是在运行时向内存分配器申请的
* 当我们处理完字符串之后，需要一种将内存归还给分配器的方法

第一部分，通过调用String::from来完成，在编程语言中这是比较普遍的做法；第二步部分，不同的编程语言有较大差异，带有垃圾回收(GC)的语言，GC会跟踪并清理不再使用的内存，我们写代码的时候不用关心这部分。而对于大部分不带GC的语言，这是程序员的职责，程序员需要去识别何时不再使用内存，并调用代码显性的释放它，就像申请内存时的操作一样。在合适的位置和时间正确的释放内存一直是个编程难题，或者说是一个容易出bug的点。如果忘记释放内存，就会导致内存泄露；如果释放的太早，就会导致访问的变量无效，进而踩内存或者Crash；如果重复释放，也是一个bug。

对于第二个部分，Rust采用了一个不同的路径：一旦变量超出它的作用域，内存就会自动被回收，如下，当s变量超过了作用域范围，Rust会自动调用一个特殊的函数drop来释放内存。
```rust
    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid

```
目前看上去，Rust的这种模式很简单且很容易理解，但在更复杂的情况下，代码的行为也会更加复杂，我们接着往下看。

### 1.6 变量和数据的交互方式：Move

对于简单类型的变量，数据的移动是比较简单的，即直接的拷贝，例如：
```rust
    let x = 5;
    let y = x;
```
这里，首先为变量x绑定数值5，然后然后复制x中的值，并将其绑定给y。整个过程都发生在栈中。

对于String类型则不太一样，一个String变量由三部分组成：
* 一个指针：指向存储在堆中的字符串内容
* 长度：字符串内容的长度，单位：字节
* 容量：从分配器收到的内存总量，单位：字节

这三部分作为一个整体存储在栈中，而字符串内容则存储在堆中。长度和容量之间的区别很重要，但在这种情况下并不重要，所以现在，忽略容量是可以的。
```rust
    let s1 = String::from("hello");
    let s2 = s1;
```
当将s1赋值给s2的时候，实际上只拷贝了栈中指针，长度和容量，堆中的字符串内存并没有发生拷贝。这样做的好处是，如果堆中的数据块很大，可以避免拷贝带来的运行时开销。之前，我们说过，当一个变量超出其作用域，Rust就会自动调用drop函数并清理这个变量堆中占用的内存。但是上面的例子，s2和s1两个变量同时指向了堆中的同一块内存，因此这里就存在一个问题：当s2和s1超出其各自作用域时，都会尝试这一块内存，从而产生内存的重复释放，这是我们之前提到过的一个内存安全问题。

为了确保内存安全，Rust采取了这样的做法：在“let s2 = s1”这行之后，Rust认为s1不再有效。因此当s1超出其作用域时，不再需要释放内存。因此，在s1赋值给s2之后，如果再使用s1，编译的时候就会报错。这个例子演示了Rust所有权转移的过程，且对应上了Rust所有权的一个原则：数据一次只能有一个所有者。

下面是一个s1失效后又使用，从而引起编译器报错的示例：
```rust
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
```
```bash
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
```

此外，这里暗含了一个设计选择：Rust绝不会自动创建你的数据的深度copy，即不会自动拷贝堆中的数据。因此，可以认为在运行时任何自动拷贝都是低开销的。

###  1.7 变量和数据的交互方式：Clone

如果我们希望深度拷贝String变量堆中的数据，而不仅仅是栈中的数据，我们可以使用一个叫做clone的常用方法。
```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
```
当我们使用clone来完成深度拷贝时，上面的代码并不会发生编译器报错，s1在赋值给s2后依然有效。

### 1.8 仅栈数据：Copy

还有一个我们没有讨论到的破绽，像整数这类变量，他们的赋值是否会发生所有权的转移和变量的无效？首先说答案，不会。下面是个例子：
```rust
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
```
但是这段代码似乎与我们刚刚学到的相矛盾：我们没有调用 clone，但是 x 仍然有效并且没有被移动到 y 中。

这是因为像整数这种类型在编译时是有已知的大小的，且整个存储在栈中，因此真实数据的拷贝是快速的。这意味着我们没有理由在创建y之后阻止x继续有效。换句话说，这里的深拷贝和浅拷贝没有区别，所有调用clone与通常的浅拷贝没有什么不同，所以可以省略ta。




# Reference
1. [The Rust Programming Language][1]

[1]: https://doc.rust-lang.org/book/